package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	_ "github.com/go-sql-driver/mysql" // MySQL driver
)

// --------------------
// STRUCT: Input Data
// --------------------
type EkycProductInput struct {
	RequestUID          string `json:"request_uid"`
	ParticipantCategory string `json:"participant_category"`
	Products            string `json:"products"`
	SessionID           string `json:"session_id"`
	UpdatedSessionID    string `json:"updated_session_id"`
	IsActive            string `json:"is_active"`
}

// --------------------
// DATABASE CONNECTION
// --------------------
func connectDB() (*sql.DB, error) {
	db, err := sql.Open("mysql", "username:password@tcp(localhost:3306)/yourdbname")
	if err != nil {
		return nil, err
	}
	return db, nil
}

// --------------------
// STEP 1: COLLECT → Read & Unmarshal JSON
// --------------------
func Collect(r *http.Request) (EkycProductInput, error) {
	var input EkycProductInput

	body, err := io.ReadAll(r.Body)
	if err != nil {
		return input, fmt.Errorf("failed to read request body: %v", err)
	}

	err = json.Unmarshal(body, &input)
	if err != nil {
		return input, fmt.Errorf("invalid JSON format: %v", err)
	}

	return input, nil
}

// --------------------
// STEP 2: VALIDATE → Check mandatory fields
// --------------------
func Validate(input EkycProductInput) error {
	if input.RequestUID == "" || input.Products == "" {
		return fmt.Errorf("missing required fields: request_uid or products")
	}
	return nil
}

// --------------------
// STEP 3: ASSIGN → Handle isActive & other defaults
// --------------------
func Assign(input *EkycProductInput) {
	if input.IsActive == "" {
		input.IsActive = "N"
	} else if input.IsActive == "true" {
		input.IsActive = "Y"
	} else if input.IsActive == "false" {
		input.IsActive = "N"
	}
}

// --------------------
// STEP 4: CONSTRUCT → Insert data into DB
// --------------------
func Construct(db *sql.DB, input EkycProductInput) error {
	query := `
		INSERT INTO ekyc_mcx_products 
		(request_uid, participant_category, products, session_id, updated_session_id, createdate, updatedAt, isActive)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`

	stmt, err := db.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %v", err)
	}
	defer stmt.Close()

	_, err = stmt.Exec(
		input.RequestUID,
		input.ParticipantCategory,
		input.Products,
		input.SessionID,
		input.UpdatedSessionID,
		time.Now().Unix(),
		time.Now().Unix(),
		input.IsActive,
	)
	if err != nil {
		return fmt.Errorf("insert failed: %v", err)
	}
	return nil
}

// --------------------
// EXISTING API HANDLER
// --------------------
func existingAPIHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}

	// Step 1: Collect
	input, err := Collect(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Step 2: Validate
	err = Validate(input)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Step 3: Assign
	Assign(&input)

	// Step 4: Construct (Insert into DB)
	db, err := connectDB()
	if err != nil {
		http.Error(w, "Database connection failed", http.StatusInternalServerError)
		return
	}
	defer db.Close()

	err = Construct(db, input)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Step 5: Marshal response
	response := map[string]string{
		"status":  "success",
		"message": "Data inserted successfully",
	}
	respJSON, _ := json.Marshal(response)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respJSON)
}

// --------------------
// MAIN FUNCTION
// --------------------
func main() {
	http.HandleFunc("/existingAPI", existingAPIHandler)
	fmt.Println("✅ Server running on http://localhost:8080")
	http.ListenAndServe(":8080", nil)
}
